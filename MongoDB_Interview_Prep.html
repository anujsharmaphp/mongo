<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MongoDB Interview Prep</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: #f8f9fa; color: #1e293b; line-height: 1.6; }

        .layout { display: flex; min-height: 100vh; }

        /* Sidebar */
        .sidebar {
            width: 260px;
            min-width: 260px;
            background: #fff;
            border-right: 1px solid #e2e8f0;
            padding: 24px 0;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            overflow-y: auto;
        }
        .sidebar h2 { font-size: 15px; color: #0f766e; padding: 0 20px; margin-bottom: 4px; }
        .sidebar .sub { font-size: 11px; color: #94a3b8; padding: 0 20px; margin-bottom: 20px; }
        .sidebar nav a {
            display: block;
            padding: 9px 20px;
            font-size: 13px;
            color: #475569;
            text-decoration: none;
            border-left: 3px solid transparent;
            transition: all 0.2s;
        }
        .sidebar nav a:hover { background: #f0fdf4; color: #0f766e; border-left-color: #0f766e; }
        .sidebar nav a.active { background: #f0fdf4; color: #0f766e; border-left-color: #0f766e; font-weight: 600; }
        .sidebar nav a.pending { color: #cbd5e1; }

        /* Main content */
        .main { margin-left: 260px; padding: 30px 40px; max-width: 820px; }

        /* Concept block */
        .concept { background: #fff; border-radius: 10px; padding: 28px; margin-bottom: 24px; border: 1px solid #e2e8f0; }
        .concept h2 { font-size: 20px; color: #0f766e; margin-bottom: 4px; }
        .concept .tag { display: inline-block; background: #f0fdf4; color: #0f766e; font-size: 11px; padding: 2px 10px; border-radius: 20px; margin-bottom: 14px; font-weight: 500; }

        /* Simple points */
        .point { margin-bottom: 14px; }
        .point strong { color: #0f766e; font-size: 13px; }
        .point p { font-size: 13px; color: #475569; margin-top: 2px; }
        .point ul { padding-left: 18px; margin-top: 4px; }
        .point li { font-size: 12.5px; color: #475569; margin-bottom: 3px; }
        .point li strong { color: #1e293b; }

        /* Code */
        pre { background: #f1f5f9; border-radius: 8px; padding: 14px; overflow-x: auto; margin: 10px 0; border: 1px solid #e2e8f0; }
        code { font-family: 'Fira Code', monospace; font-size: 12px; color: #0f766e; }

        /* Q&A */
        .qa h3 { font-size: 13px; color: #b45309; margin: 18px 0 10px; text-transform: uppercase; letter-spacing: 1px; border-top: 1px solid #e2e8f0; padding-top: 16px; }
        .q { background: #fffbeb; border-radius: 8px; padding: 12px 14px; margin-bottom: 8px; border: 1px solid #fde68a; }
        .q .question { font-size: 13px; font-weight: 600; color: #1e293b; margin-bottom: 6px; }
        .q .answer { font-size: 12.5px; color: #57534e; }
        .q .answer strong { color: #1e293b; }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar { display: none; }
            .main { margin-left: 0; padding: 20px; }
        }
    </style>
</head>
<body>
<div class="layout">

    <!-- Sidebar -->
    <aside class="sidebar">
        <h2>MongoDB Prep</h2>
        <p class="sub">Interview Guide</p>
        <nav>
            <a href="#concept-1" class="active">1. Fundamentals</a>
            <a href="#concept-2">2. Schema Design</a>
            <a href="#concept-3" class="pending">3. Indexing</a>
            <a href="#concept-4" class="pending">4. Aggregation</a>
            <a href="#concept-5" class="pending">5. Sharding</a>
            <a href="#concept-6" class="pending">6. Replication</a>
            <a href="#concept-7" class="pending">7. Atlas & Cloud</a>
            <a href="#concept-8" class="pending">8. Performance Tuning</a>
            <a href="#concept-9" class="pending">9. Transactions</a>
            <a href="#concept-10" class="pending">10. Security</a>
            <a href="#concept-11" class="pending">11. Kafka + MongoDB</a>
            <a href="#concept-12" class="pending">12. Mongo vs Elastic</a>
            <a href="#concept-13" class="pending">13. Project Scenarios</a>
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main">

        <!-- CONCEPT 1 -->
        <div class="concept" id="concept-1">
            <h2>1. Fundamentals & Architecture</h2>
            <span class="tag">Core Foundation</span>

            <div class="point">
                <strong>What is MongoDB?</strong>
                <p>NoSQL document database. Stores data as BSON (Binary JSON) documents. No fixed schema needed.</p>
            </div>

            <div class="point">
                <strong>Structure (vs MySQL)</strong>
                <ul>
                    <li><strong>Database</strong> = Database</li>
                    <li><strong>Collection</strong> = Table</li>
                    <li><strong>Document</strong> = Row (but flexible, no fixed columns)</li>
                    <li><strong>Field</strong> = Column</li>
                    <li><strong>_id</strong> = Primary Key (auto-generated 12-byte ObjectId)</li>
                </ul>
            </div>

            <div class="point">
                <strong>ObjectId (12 bytes)</strong>
                <p>4 bytes timestamp + 5 bytes random + 3 bytes counter. Sortable by creation time.</p>
            </div>

            <div class="point">
                <strong>WiredTiger Engine</strong>
                <ul>
                    <li><strong>Document-level locking</strong> &mdash; multiple writes to different docs at same time</li>
                    <li><strong>Compression</strong> &mdash; Snappy (default), zstd (better ratio)</li>
                    <li><strong>Journal</strong> &mdash; WAL synced every 50ms for crash recovery</li>
                    <li><strong>Checkpoint</strong> &mdash; flushes to disk every 60 seconds</li>
                    <li><strong>Cache</strong> &mdash; uses 50% of (RAM - 1GB)</li>
                </ul>
            </div>

            <div class="point">
                <strong>BSON vs JSON</strong>
                <p>BSON adds types: Date, ObjectId, Decimal128, Int64, BinData. Faster to parse. Max doc = <strong>16MB</strong>.</p>
            </div>

            <div class="point">
                <strong>CRUD Examples</strong>
<pre><code>// INSERT
db.patients.insertOne({ name: "Rajesh", age: 45, codes: ["E11", "I10"] })
db.patients.insertMany([{ name: "A" }, { name: "B" }])

// FIND
db.patients.find({ age: { $gte: 30 } })       // age >= 30
db.patients.find({ "records.bp": "140/90" })   // nested
db.patients.find({ codes: "E11" })             // array contains

// UPDATE
db.patients.updateOne(
  { name: "Rajesh" },
  { $set: { age: 46 }, $push: { codes: "M19" } }
)

// DELETE
db.patients.deleteMany({ age: { $lt: 18 } })</code></pre>
            </div>

            <div class="point">
                <strong>Key Operators (remember these)</strong>
                <ul>
                    <li><strong>Compare:</strong> $eq, $ne, $gt, $gte, $lt, $lte, $in, $nin</li>
                    <li><strong>Logic:</strong> $and, $or, $not, $nor</li>
                    <li><strong>Array:</strong> $all, $elemMatch, $size, $push, $pull, $addToSet</li>
                    <li><strong>Update:</strong> $set, $unset, $inc, $rename, $pop</li>
                    <li><strong>Element:</strong> $exists, $type</li>
                </ul>
            </div>

            <div class="point">
                <strong>Write Concern (durability level)</strong>
                <ul>
                    <li><code>w: 1</code> &mdash; acknowledged by primary only</li>
                    <li><code>w: "majority"</code> &mdash; acknowledged by majority of replica set</li>
                    <li><code>j: true</code> &mdash; wait until written to journal</li>
                </ul>
            </div>

            <div class="point">
                <strong>Read Preference</strong>
                <ul>
                    <li><strong>primary</strong> &mdash; always read from primary (default, strongest consistency)</li>
                    <li><strong>secondary</strong> &mdash; read from secondaries (for analytics, may be stale)</li>
                    <li><strong>nearest</strong> &mdash; lowest latency node</li>
                </ul>
            </div>

            <div class="qa">
                <h3>Interview Q&A</h3>

                <div class="q">
                    <div class="question">Q: Why MongoDB over MySQL for medical data?</div>
                    <div class="answer">Medical records are semi-structured &mdash; each encounter has different fields, nested labs, NLP-extracted codes. MongoDB's flexible schema avoids ALTER TABLE. One patient doc embeds vitals + diagnoses + AI-codes as nested objects, <strong>no JOINs needed</strong> at read time.</div>
                </div>

                <div class="q">
                    <div class="question">Q: How does WiredTiger handle concurrency?</div>
                    <div class="answer"><strong>Document-level concurrency</strong> with MVCC (Multi-Version Concurrency Control). Readers see a consistent snapshot without blocking writers. Different from MySQL's row-level locking &mdash; MongoDB is optimistic, no lock waits on different docs.</div>
                </div>

                <div class="q">
                    <div class="question">Q: Max document size? What if data is bigger?</div>
                    <div class="answer"><strong>16MB</strong>. For larger files use <strong>GridFS</strong> (splits into 255KB chunks across fs.files + fs.chunks). Or store files in S3 and keep reference URL in MongoDB.</div>
                </div>

                <div class="q">
                    <div class="question">Q: Explain ObjectId structure.</div>
                    <div class="answer">12 bytes: <strong>4</strong> (unix timestamp) + <strong>5</strong> (random/machine) + <strong>3</strong> (incrementing counter). Unique across distributed systems. Roughly sortable by time.</div>
                </div>

                <div class="q">
                    <div class="question">Q: Difference between insertMany and bulkWrite?</div>
                    <div class="answer"><code>insertMany</code> = batch inserts only. <code>bulkWrite</code> = mixed operations (insert + update + delete) in one request. Use bulkWrite for Kafka event processing &mdash; batch hundreds of price/inventory updates per second.</div>
                </div>

                <div class="q">
                    <div class="question">Q: How does MongoDB ensure durability?</div>
                    <div class="answer">3 layers: (1) <strong>Journal/WAL</strong> synced every 50ms, (2) <strong>Checkpoint</strong> every 60s, (3) <strong>Write Concern</strong> &mdash; <code>w:"majority", j:true</code> for max safety. For healthcare, always use majority + journal.</div>
                </div>

                <div class="q">
                    <div class="question">Q: When to use which Read Preference?</div>
                    <div class="answer"><strong>primary</strong> for real-time medical coding (consistency matters). <strong>secondaryPreferred</strong> for analytics dashboards (slight staleness OK). <strong>nearest</strong> for geo-distributed reads (lowest latency).</div>
                </div>

                <div class="q">
                    <div class="question">Q: BSON vs JSON &mdash; why not just store JSON?</div>
                    <div class="answer">BSON adds types (Date, Decimal128, ObjectId) that JSON lacks. Has length prefixes for O(1) field skipping. Faster encode/decode. Slightly larger on wire but optimized for traversal.</div>
                </div>
            </div>
        </div>

        <!-- CONCEPT 2 -->
        <div class="concept" id="concept-2">
            <h2>2. Document Modeling & Schema Design</h2>
            <span class="tag">Most Asked Topic</span>

            <div class="point">
                <strong>Golden Rule</strong>
                <p>Design schema based on <strong>how your app reads data</strong>, not how data is related. Opposite of MySQL normalization.</p>
            </div>

            <div class="point">
                <strong>Embedding vs Referencing</strong>
                <ul>
                    <li><strong>Embed</strong> = put related data inside the same document (denormalize)</li>
                    <li><strong>Reference</strong> = store _id link to another collection (like foreign key)</li>
                </ul>
<pre><code>// EMBEDDED - patient with vitals inside
{
  _id: ObjectId("..."),
  name: "Rajesh",
  vitals: [
    { date: "2024-01-10", bp: "140/90", sugar: 280 },
    { date: "2024-01-11", bp: "130/85", sugar: 220 }
  ]
}

// REFERENCED - vitals in separate collection
// patients collection
{ _id: ObjectId("p1"), name: "Rajesh" }

// vitals collection
{ _id: ObjectId("v1"), patientId: ObjectId("p1"), bp: "140/90" }
{ _id: ObjectId("v2"), patientId: ObjectId("p1"), bp: "130/85" }</code></pre>
            </div>

            <div class="point">
                <strong>When to Embed (use most of the time)</strong>
                <ul>
                    <li>Data is read together &mdash; "give me patient + vitals in one query"</li>
                    <li>1:1 relationship (user &rarr; profile)</li>
                    <li>1:Few relationship (order &rarr; 5-10 items)</li>
                    <li>Data doesn't grow unbounded</li>
                    <li>Atomic updates needed on parent + child</li>
                </ul>
            </div>

            <div class="point">
                <strong>When to Reference</strong>
                <ul>
                    <li>1:Many with unbounded growth (user &rarr; millions of logs)</li>
                    <li>Many:Many relationship (students &harr; courses)</li>
                    <li>Data accessed independently ("show me just the order, not user")</li>
                    <li>Document would exceed 16MB</li>
                    <li>Data shared across many parents</li>
                </ul>
            </div>

            <div class="point">
                <strong>Schema Design Patterns (important!)</strong>
                <ul>
                    <li><strong>Bucket Pattern</strong> &mdash; group time-series data into buckets (e.g., 1 doc = 1 hour of sensor readings)</li>
                    <li><strong>Outlier Pattern</strong> &mdash; handle documents where arrays grow beyond normal (flag + overflow collection)</li>
                    <li><strong>Computed Pattern</strong> &mdash; pre-calculate values (total, average) instead of computing on every read</li>
                    <li><strong>Subset Pattern</strong> &mdash; embed only recent/frequent data, keep rest in separate collection</li>
                    <li><strong>Extended Reference</strong> &mdash; copy frequently needed fields from referenced doc to avoid $lookup</li>
                    <li><strong>Polymorphic Pattern</strong> &mdash; different doc shapes in same collection (sports cards, game cards, all in "products")</li>
                </ul>
            </div>

            <div class="point">
                <strong>Bucket Pattern Example (Healthcare)</strong>
<pre><code>// Instead of 1 doc per vital reading (millions of docs)
// Group into hourly buckets
{
  patientId: ObjectId("p1"),
  date: ISODate("2024-01-10"),
  hour: 14,
  readings: [
    { time: "14:00", bp: "140/90", temp: 98.6 },
    { time: "14:15", bp: "138/88", temp: 98.4 },
    { time: "14:30", bp: "135/85", temp: 98.5 }
  ],
  count: 3,
  avgBp: "137/87"  // computed pattern combined
}</code></pre>
            </div>

            <div class="point">
                <strong>Polymorphic Pattern Example (eCommerce)</strong>
<pre><code>// Same "products" collection, different shapes
// Sports card
{
  type: "sports_card",
  name: "Mike Trout RC",
  sport: "baseball",
  year: 2011,
  graded: true,
  grade: "PSA 10"
}
// Game card
{
  type: "game_card",
  name: "Black Lotus",
  game: "MTG",
  set: "Alpha",
  rarity: "rare",
  foil: false
}</code></pre>
            </div>

            <div class="point">
                <strong>Anti-Patterns (avoid these)</strong>
                <ul>
                    <li><strong>Massive arrays</strong> &mdash; unbounded arrays slow down reads and hit 16MB limit</li>
                    <li><strong>Unnecessary normalization</strong> &mdash; don't split data into 10 collections like MySQL</li>
                    <li><strong>No indexes on referenced fields</strong> &mdash; $lookup without index = full collection scan</li>
                    <li><strong>Storing blobs in document</strong> &mdash; use GridFS or S3 for files</li>
                </ul>
            </div>

            <div class="point">
                <strong>$lookup (JOIN equivalent)</strong>
<pre><code>// Get patient with their lab reports from separate collection
db.patients.aggregate([
  { $match: { name: "Rajesh" } },
  { $lookup: {
      from: "lab_reports",
      localField: "_id",
      foreignField: "patientId",
      as: "labs"
  }}
])</code></pre>
                <p>$lookup is expensive. If you need it frequently, consider embedding or extended reference pattern instead.</p>
            </div>

            <div class="point">
                <strong>Schema Validation</strong>
<pre><code>db.createCollection("patients", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "age"],
      properties: {
        name: { bsonType: "string", description: "required" },
        age:  { bsonType: "int", minimum: 0, maximum: 150 }
      }
    }
  },
  validationLevel: "strict",    // or "moderate"
  validationAction: "error"     // or "warn"
})</code></pre>
            </div>

            <div class="qa">
                <h3>Interview Q&A</h3>

                <div class="q">
                    <div class="question">Q: How did you design the schema for medical records?</div>
                    <div class="answer">Used <strong>embedding</strong> for patient + encounter data (vitals, ICD codes, NLP entities) since they're always read together. Used <strong>bucket pattern</strong> for time-series vitals to reduce doc count. Used <strong>referencing</strong> for lab reports since they can be accessed independently and grow unbounded.</div>
                </div>

                <div class="q">
                    <div class="question">Q: Embed or Reference? How do you decide?</div>
                    <div class="answer">Ask 3 questions: (1) Is data read together? &rarr; embed. (2) Does it grow unbounded? &rarr; reference. (3) Is it shared by multiple parents? &rarr; reference. Default to embedding unless there's a reason not to. MongoDB is optimized for single-doc reads.</div>
                </div>

                <div class="q">
                    <div class="question">Q: What schema pattern did you use for the eCommerce collectibles platform?</div>
                    <div class="answer"><strong>Polymorphic pattern</strong> &mdash; sports cards, game cards, and collectibles all in one "products" collection with different field shapes. This enabled a single search index across all product types. Also used <strong>extended reference</strong> &mdash; copied seller name + rating into product doc to avoid $lookup on every product listing.</div>
                </div>

                <div class="q">
                    <div class="question">Q: What is the Bucket Pattern and when to use it?</div>
                    <div class="answer">Groups time-series data into buckets (e.g., 1 doc = 1 hour). Instead of millions of individual readings, you get thousands of bucket docs. Reduces index size, improves write performance. Used for patient vitals monitoring &mdash; each bucket holds readings for one hour with pre-computed averages.</div>
                </div>

                <div class="q">
                    <div class="question">Q: How do you handle Many-to-Many in MongoDB?</div>
                    <div class="answer">Two approaches: (1) <strong>Array of references</strong> in both sides &mdash; student has courseIds[], course has studentIds[]. (2) <strong>Junction collection</strong> for unbounded or with extra attributes &mdash; enrollment { studentId, courseId, grade, date }. Choose based on array growth.</div>
                </div>

                <div class="q">
                    <div class="question">Q: $lookup performance &mdash; is it like a SQL JOIN?</div>
                    <div class="answer">Similar but <strong>much slower</strong>. $lookup does a full collection scan on "from" collection unless the foreignField is indexed. It doesn't use hash joins or merge joins. Best practice: (1) always index foreignField, (2) if $lookup is frequent, consider denormalizing with embedding or extended reference pattern.</div>
                </div>

                <div class="q">
                    <div class="question">Q: What is Schema Validation in MongoDB?</div>
                    <div class="answer">MongoDB supports <strong>$jsonSchema</strong> validation on collections. Define required fields, types, min/max, enums. Set <code>validationLevel: "strict"</code> to enforce on all writes, or <code>"moderate"</code> to only validate new inserts. Set <code>validationAction: "error"</code> to reject or <code>"warn"</code> to just log.</div>
                </div>

                <div class="q">
                    <div class="question">Q: What are common schema design anti-patterns?</div>
                    <div class="answer">(1) <strong>Unbounded arrays</strong> &mdash; arrays that grow forever slow reads, hit 16MB. (2) <strong>Over-normalization</strong> &mdash; splitting into too many collections like SQL, causing excessive $lookups. (3) <strong>Bloated documents</strong> &mdash; embedding data that's rarely accessed. (4) <strong>No validation</strong> &mdash; flexible schema doesn't mean no rules, use $jsonSchema.</div>
                </div>
            </div>
        </div>

    </main>
</div>

<script>
    // Highlight active sidebar link on scroll
    const links = document.querySelectorAll('.sidebar nav a');
    const sections = document.querySelectorAll('.concept');
    window.addEventListener('scroll', () => {
        let current = '';
        sections.forEach(s => {
            if (window.scrollY >= s.offsetTop - 100) current = s.id;
        });
        links.forEach(a => {
            a.classList.remove('active');
            if (a.getAttribute('href') === '#' + current) a.classList.add('active');
        });
    });
</script>
</body>
</html>